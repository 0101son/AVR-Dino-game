# AVR-Dino-game

<p align="right">B915093 손주영</p>

# 소개
---
이 프로젝트는 크롬 브라우저에 포함된 게임으로 유명한 "공룡 게임"을 AVR에서 구현한 프로젝트입니다.
저는 게임을 만드는 것을 좋아하여 이전에 C#을 이용하여 유니티 엔진으로 게임을 만들어본 경험이 있습니다. 이 경험을 살려 강의에서 배운 내용을 기반으로 PC가 아닌 AVR이라는 새로운 환경에서 게임을 구현해보는 도전을 해보고 싶었습니다.

### 과목 연결성
---
이 프로젝트는 강의에서 배운 내용 중
- 세븐 세그먼트
- 외부 인터럽트(푸시버튼)
- 오버플로우 타이머(스피커 소리 출력 및 조절)
를 사용하였습니다.

### 기타 사항
---
이 프로젝트는 게임을 제작하는 프로젝트이므로, 구현에 객체지향 개발 환경이 더 적합하다 판단되어 C가 아닌 C++에서 만들었습니다.
기능 별로 클래스를 만들고 파일을 분할하여 여러개의 파일로 구성하였습니다.

# 기술적 배경
---
### 세븐 세그먼트
---

![Pasted image 20231021234400](https://github.com/user-attachments/assets/c0c8f0f1-86bf-43df-aba9-97b5e7cd3474)


적용: 공룡, 장애물과 게임오버 시 점수를 표시하는데 사용하였습니다.
### 인터럽트
---
인터럽트는 프로세서가 현재 작업 중이던 작업을 중단하고 다른 작업을 먼저 처리하도록 하는 역할을 합니다.
- SREG(Status Register): 전역 인터럽트를 활성화하는데 필요한 레지스터입니다.
- ISR (Interrupt Service Routine): 특정 인터럽트 발생 시 호출됩니다.
##### 외부 인터럽트(푸시버튼)
- EIMSK (External Interrupt Mask Register): 외부 인터럽트 활성화 여부를 정하는 레지스터 입니다.
- EICR (External Interrupt Control Register): 외부 인터럽트를 작동 시키는 조건(Rising, Falling 등)을 정하는 레지스터 입니다. 
- INTN\_vect: 특정 외부 인터럽트의 벡터 입니다. N에는 인터럽트 핀 번호가 들어갑니다.
적용: 외부 인터럽트의 공룡의 점프 버튼을 만들었습니다. 길게 누르면 더 오래 뛰도록 버튼을 누르고 땔 때 마다 EICR을 변경하여 더 섬세한 조작을 구현하였습니다.
##### 오버플로우 타이머
- OVF(Overflow Interrupt): AVR 내부 타이머/카운터(TCNT)가 증가하다가 최대값에서 하나 더 증가하는 오버플로우가 발생하면 실행되는 인터럽트 입니다.
- TCCR: 타이머/카운터가 동작하는 모드를 설정합니다. 
	- Normal: TCNT가 0에서 최대값(OVF)에 도달하면 초기화. 고정 주기
	- CTC: TCNT가 OCR이 되면 하드웨어(정확함)에서 초기화. 변동 주기
	- PWM: OCR에서 HIGH/LOW가 바뀐다. 고정 주기
	
적용: 오버플로우 타이머 2개를 사용하여 하나는 주파수, 나머지 하나는 음의 길이를 제어하여 게임 진행과 비동기적으로 작동하는 음향 효과를 구현하였습니다.  
### 동적 할당 불가
---
C++에서는 'new', 'delete'로 동적 메모리 할당을 지원하나, AVR 환경에서는 메모리 활용이 열악하여 이를 지원하지 않습니다. 때문에 구현에 있어 클래스로 변수, 메서드를 상속받거나 인스턴스를 생성하는데 제약이 있었습니다.
	
적용: 공룡, 장애물과 같은 오브젝트를 인스턴스 대신 스태틱 함수와 변수를 가진 클래스로 구현하였습니다.

# 개발 과정
---
### 프로그램 구상
- 2번째 세그먼트에 플레이어가 조작할 수 있는 공룡이 표시된다.
- 공룡은 버튼을 눌러 점프를 할 수 있고, 점프를 하면 점프하기 전 보다 한 칸 위에 표시된다.
- 누른 버튼을 떼거나 최대 체공시간 이상 공중에 있으면 다시 땅으로 내려온다. 
- 4번째 세그먼트에서 장애물이 주기적으로 나타나며, 한 칸씩 왼쪽으로 다가온다.
- 점프를 하면 장애물을 넘어갈 수 있고, 점수가 1점 추가된다.
- 지상에 있는 상태로 다가오는 장애물과 부딪히면 게임이 종료된다.
- 게임이 종료되면 점수가 출력 된다.

### 프로그램 구조 설계
---

![d_FA6e9yde](https://github.com/user-attachments/assets/4d3f0ec7-3ce6-4ee0-b278-e763191927d8)

- **Main**: 프로그램의 주 실행 파일입니다. 이는 게임의 다른 주요 컴포넌트들을 사용하며, 기능 초기화 및 게임 모드 설정을 통해 실행 흐름을 제어합니다.
    
- **Dino**: 공룡 캐릭터를 나타내는 클래스입니다. 이는 "GameObject"로부터 상속받으며, 장애물과 상호작용하고 사운드 매니저를 사용합니다.
    
- **Obstacle**: 게임 내의 장애물을 나타내는 클래스입니다. 이 역시 "GameObject"로부터 상속받으며, 사운드 매니저를 사용합니다.
    
- **SoundManager**: 게임 내의 사운드를 관리하는 클래스입니다. 공룡과 장애물에 의해 사용되며, 스피커를 통해 소리를 출력합니다.
    
- **Jump Button**: 게임 내에서 공룡의 점프를 트리거하는 외부 인터럽트입니다. Main과 연결되어 있으며, Dino에 점프 명령을 전달합니다.
    
- **4 7-Segment Display & Speaker**: 게임의 시각적 및 청각적 출력을 담당하는 장치입니다. 세븐 세그먼트 디스플레이는 공룡과 장애물 정보 및 점수를 표시하고, 스피커는 사운드 매니저에서 오는 소리를 재생합니다.
	
- **GameObject**: 공룡과 장애물 클래스가 공통적으로 상속받는 베이스 클래스입니다. 게임 내의 기본적인 오브젝트 구조를 정의합니다.
# 구현 세부사항
---
### main.cpp

- 세븐 세그먼트
``` C++
void showCharacters(){
	unsigned char segment;
	for(int i = 0; i<4;i++){	//네 7세그먼트에서 각각 출력할 내용을 bitwise OR 연산으로 겹쳐 출력합니다.
		segment = 0;
		segment |= Dino::displaySeg(i);
		segment |= Obstacle::displaySeg(i);
		
		PORTC=~(1<<i);		//출력할 7세그먼트 옯기기
		
		PORTA = segment;	//출력
		
		_delay_ms(2);
	}	
};
```
세븐 세그먼트로 캐릭터를 출력하는 함수 입니다.

- 외부 인터럽트
```C++
ISR(INT0_vect){	//푸시 버튼을 누르면 호출됩니다. 
	if(gameMode == MAINGAME){
		if(PIND & 1){
			//버튼 누름
			EICRA &=0;	//버튼을 땔 때 인터럽트가 작동하도록 설정
			Dino::jump(); //점프 명령
			}else{
			//버튼 땜
			EICRA |=1;	//버튼을 누를 때 인터럽트가 작동하도록 설정
			Dino::land(); //착지 명령
		}
	}
}
```
버튼을 누르고 때는 것을 감지하기 위한 외부 인터럽트 처리 코드 입니다.

### SoundManager.cpp

- 오버플로우 타이머
```C++
ISR(TIMER0_OVF_vect){
	TCNT0 = SoundManager::Timer0Value;
	if (SoundManager::isSoundOn) {
		PORTF ^= 0x80; // isSoundOn이 true일 때만 토글
	}
}

ISR(TIMER2_OVF_vect) {
	SoundManager::noteTimeCounter++; // 음의 길이 카운팅

	if (SoundManager::noteTimeCounter == 15) {
		SoundManager::noteTimeCounter = 0; // 카운터 재설정

		if (SoundManager::noteCount  < 1) {
			// 다음 음 재생
			SoundManager::Timer0Value = 255-(1000000/(8*C1)); // 다음 음의 주파수 값 설정
			SoundManager::noteCount++; // 다음 음으로 넘어가기
		} else {
			// 모든 음 재생 완료
			SoundManager::isSoundOn = false; // 소리 재생 중지
			SoundManager::noteCount = 0; // 음 카운터 초기화
		}
	}
}
```
게임 진행 중 \_delay\_ms()를 실행하면 게임이 중간에 정지되어버리므로, 소리 출력을 2개의 타이머를 사용하여 구현하였습니다.

# 결론
---
### 최종 결과
버튼을 눌러 다가오는 장애물을 점프로 뛰어넘는 공룡 게임을 스피커의 효과음과 함께 7segment 디스플레이로 AVR에서 구현할 수 있었습니다. 게임의 시작과 끝이 명확하고, 다가오는 장애물의 속도가 게임이 진행될수록 점점 빨라지는 변화도 구현하여 게임을 즐기기에 문제가 없었습니다. 

### 성과 및 학습점
- AVR의 특징인 인터럽트, 카운터를 다양하게 사용해보는 도전적인 경험을 할 수 있었습니다. 외부 인터럽트 처리는 EICRA를 계속 변경하여 버튼의 누르고 때는 섬세한 조작을 구현했고, 카운터는 두 개를 동시에 사용하며 서로에게 영향을 주도록 만들었습니다.
- 학교에서 배운 파이썬, 독학한 C, 게임 개발을 위한 C#을 사용해본 적이 있어 객체지향과 알고리즘에 대한 지식과 경험은 있었으나, C++을 사용해 본 적은 없었습니다. 프로젝트 제작 기간 중 하루 정도를 PWM과 음정을 동시에 제어하는 프로젝트를 구현하려다 중단하고 새 프로젝트를 시작하여 일정 상 시간이 부족했고 사용할 언어도 바뀌었기에, 부족한 시간 동안 최대한의 생산성을 얻고자 Chat GPT의 도움을 받았습니다. C++ 문법에서 도움을 받았고, 자료 중간에 삽입된 그래프도 생성하였습니다. 덕분에 그래프를 그리는 시간을 아낄 수 있었고, 강의 외의 내용 중 프로젝트에 필요한 많은 것을 빠르게 배울 수 있었습니다.
### 개선점 및 향후 계획
- **개선할 점**: 당장 게임을 즐기는 데는 문제가 없었으나, 7세그먼트를 출력할 때 사용한 delay\_ms\_()를 또 다른 타이머 오버플로우 인터럽트를 사용하여 비동기식으로 처리한다면 좀 더 깔끔한 소리와 출력을 얻을 수 있을 것으로 기대됩니다.
- **향후 계획**: 저번 여름방학에 아두이노를 활용한 프로젝트를 진행한 적이 있었으나, 임베디드에 익숙하지 않아 어려움을 겪은 경험이 있었습니다. 다음에 아두이노나 AVR과 같은 임베디드 시스템을 사용하는 프로젝트를 진행하게 된다면, 이번 강의와 프로젝트에서 배운 내용을 바탕으로 C++, 비동기식 프로그래밍, 외부 인터럽트, PWM등 다양한 기법을 효율적으로 사용하여 더 완성도 높고 즐거운 개발을 할 수 있을 것 같습니다.
